<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/TR/MathML2/dtd/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:math="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink">
<!-- Mirrored from www.allegro.cc/manual/5/primitives.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 26 Jun 2022 21:26:54 GMT -->
<head><title>Primitives addon - Allegro 5 Manual</title><link rel="stylesheet" type="text/css" media="screen, projection" href="manual.css"/></head><body>
<div id="sidebar"><p class="site"><a href="https://www.allegro.cc/">allegro.cc</a></p><h1><a href="index.html">Manual</a></h1><div><ul><li><a href="index.html"><strong>Contents</strong></a></li><li><a href="config.html">Configuration files</a></li><li><a href="display.html">Display</a></li><li><a href="events.html">Events</a></li><li><a href="file.html">File I/O</a></li><li><a href="fshook.html">Filesystem</a></li><li><a href="fixed.html">Fixed point math</a></li><li><a href="graphics.html">Graphics</a></li><li><a href="joystick.html">Joystick</a></li><li><a href="keyboard.html">Keyboard</a></li><li><a href="memory.html">Memory</a></li><li><a href="mouse.html">Mouse</a></li><li><a href="path.html">Path</a></li><li><a href="state.html">State</a></li><li><a href="system.html">System</a></li><li><a href="threads.html">Threads</a></li><li><a href="time.html">Time</a></li><li><a href="timer.html">Timer</a></li><li><a href="transformations.html">Transformations</a></li><li><a href="utf8.html">UTF-8</a></li><li><a href="misc.html">Miscellaneous</a></li><li><a href="platform.html">Platform-specific</a></li><li><a href="direct3d.html">Direct3D</a></li><li><a href="opengl.html">OpenGL</a></li></ul></div>
<div><ul><li><a href="index.html#addons"><strong>Addons</strong></a></li><li><a href="audio.html">Audio addon</a></li><li><a href="acodec.html">Audio codecs</a></li><li><a href="color.html">Color addon</a></li><li><a href="font.html">Font addons</a></li><li><a href="image.html">Image I/O addon</a></li><li><a href="memfile.html">Memfile addon</a></li><li><a href="native_dialog.html">Native dialogs addon</a></li><li><a href="physfs.html">PhysicsFS addon</a></li><li><a href="primitives.html">Primitives addon</a></li></ul></div></div><div id="content"><h1 class="title">Primitives addon</h1><p>These functions are declared in the following header file. Link with allegro_primitives.</p><pre><code><span class="p">#include &lt;allegro5/allegro_primitives.h&gt;</span></code></pre><div id="general"><h1><span>General</span></h1><ul><li><a href="al_get_allegro_primitives_version.html">al_get_allegro_primitives_version</a></li><li><a href="al_init_primitives_addon.html">al_init_primitives_addon</a></li><li><a href="al_shutdown_primitives_addon.html">al_shutdown_primitives_addon</a></li></ul></div><div id="high-level-drawing-routines"><h1><span>High level drawing routines</span></h1><p>High level drawing routines encompass the most common usage of this addon: to draw geometric primitives, both smooth (variations on the circle theme) and piecewise linear. Outlined primitives support the concept of thickness with two distinct modes of output: hairline lines and thick lines. Hairline lines are specifically designed to be exactly a pixel wide, and are commonly used for drawing outlined figures that need to be a pixel wide. Hairline thickness is designated as thickness less than or equal to 0. Unfortunately, the exact rasterization rules for drawing these hairline lines vary from one video card to another, and sometimes leave gaps where the lines meet. If that matters to you, then you should use thick lines. In many cases, having a thickness of 1 will produce 1 pixel wide lines that look better than hairline lines. Obviously, hairline lines cannot replicate thicknesses greater than 1. Thick lines grow symmetrically around the generating shape as thickness is increased.</p><div id="pixel-precise-output"><h2><span>Pixel-precise output</span></h2><p>While normally you should not be too concerned with which pixels are displayed when the high level primitives are drawn, it is nevertheless possible to control that precisely by carefully picking the coordinates at which you draw those primitives.</p><p>To be able to do that, however, it is critical to understand how GPU cards convert shapes to pixels. Pixels are not the smallest unit that can be addressed by the GPU. Because the GPU deals with floating point coordinates, it can in fact assign different coordinates to different parts of a single pixel. To a GPU, thus, a screen is composed of a grid of squares that have width and length of 1. The top left corner of the top left pixel is located at (0, 0). Therefore, the center of that pixel is at (0.5, 0.5). The basic rule that determines which pixels are associated with which shape is then as follows: a pixel is treated to belong to a shape if the pixel's center is located in that shape. The figure below illustrates the above concepts:</p><div class="figure"><img src="images/primitives1.png" alt="&lt;em&#10;&gt;Diagram showing a how pixel output is calculated by the GPU given the mathematical description of several shapes.&lt;/em&#10;&gt;"/><p class="caption"><em>Diagram showing a how pixel output is calculated by the GPU given the mathematical description of several shapes.</em></p></div><p>This figure depicts three shapes drawn at the top left of the screen: an orange and green rectangles and a purple circle. On the left are the mathematical descriptions of pixels on the screen and the shapes to be drawn. On the right is the screen output. Only a single pixel has its center inside the circle, and therefore only a single pixel is drawn on the screen. Similarly, two pixels are drawn for the orange rectangle. Since there are no pixels that have their centers inside the green rectangle, the output image has no green pixels.</p><p>Here is a more practical example. The image below shows the output of this code:</p><pre><code><span class="c">/* blue vertical line */</span>
<a href="https://www.allegro.cc/manual/al_draw_line"><span class="a">al_draw_line</span></a><span class="k2">(</span><span class="n">0</span>.<span class="n">5</span>, <span class="n">0</span>, <span class="n">0</span>.<span class="n">5</span>, <span class="n">6</span>, color_blue, <span class="n">1</span><span class="k2">)</span><span class="k2">;</span>
<span class="c">/* red horizontal line */</span>
<a href="https://www.allegro.cc/manual/al_draw_line"><span class="a">al_draw_line</span></a><span class="k2">(</span><span class="n">2</span>, <span class="n">1</span>, <span class="n">6</span>, <span class="n">1</span>, color_red, <span class="n">2</span><span class="k2">)</span><span class="k2">;</span>
<span class="c">/* green filled rectangle */</span>
<a href="https://www.allegro.cc/manual/al_draw_filled_rectangle"><span class="a">al_draw_filled_rectangle</span></a><span class="k2">(</span><span class="n">3</span>, <span class="n">4</span>, <span class="n">5</span>, <span class="n">5</span>, color_green<span class="k2">)</span><span class="k2">;</span>
<span class="c">/* purple outlined rectangle */</span>
<a href="https://www.allegro.cc/manual/al_draw_rectangle"><span class="a">al_draw_rectangle</span></a><span class="k2">(</span><span class="n">2</span>.<span class="n">5</span>, <span class="n">3</span>.<span class="n">5</span>, <span class="n">5</span>.<span class="n">5</span>, <span class="n">5</span>.<span class="n">5</span>, color_purple, <span class="n">1</span><span class="k2">)</span><span class="k2">;</span></code></pre><div class="figure"><img src="images/primitives2.png" alt="&lt;em&#10;&gt;Diagram showing a practical example of pixel output resulting from the invocation of several primitives addon functions.&lt;/em&#10;&gt;"/><p class="caption"><em>Diagram showing a practical example of pixel output resulting from the invocation of several primitives addon functions.</em></p></div><p>It can be seen that lines are generated by making a rectangle based on the dashed line between the two endpoints. The thickness causes the rectangle to grow symmetrically about that generating line, as can be seen by comparing the red and blue lines. Note that to get proper pixel coverage, the coordinates passed to the <code>al_draw_line</code> had to be offset by 0.5 in the appropriate dimensions.</p><p>Filled rectangles are generated by making a rectangle between the endpoints passed to the <code>al_draw_filled_rectangle</code>.</p><p>Outlined rectangles are generated by symmetrically expanding an outline of a rectangle. With thickness of 1, as depicted in the diagram, this means that an offset of 0.5 is needed for both sets of endpoint coordinates.</p><p>The above rules only apply when multisampling is turned off. When multisampling is turned on, the area of a pixel that is covered by a shape is taken into account when choosing what color to draw there. This also means that shapes no longer have to contain the pixel's center to affect its color. For example, the green rectangle in the first diagram may in fact be drawn as two (or one) semi-transparent pixels. The advantages of multisampling is that slanted shapes will look smoother because they will not have jagged edges. A disadvantage of multisampling is that it may make vertical and horizontal edges blurry. While the exact rules for multisampling are unspecified, and may vary from GPU to GPU it is usually safe to assume that as long as a pixel is either completely covered by a shape or completely not covered, then the shape edges will be sharp. The offsets used in the second diagram were chosen so that this is the case: if you use those offsets, your shapes (if they are oriented the same way as they are on the diagram) should look the same whether multisampling is turned on or off.</p></div><ul><li><a href="al_draw_line.html">al_draw_line</a></li><li><a href="al_draw_triangle.html">al_draw_triangle</a></li><li><a href="al_draw_filled_triangle.html">al_draw_filled_triangle</a></li><li><a href="al_draw_rectangle.html">al_draw_rectangle</a></li><li><a href="al_draw_filled_rectangle.html">al_draw_filled_rectangle</a></li><li><a href="al_draw_rounded_rectangle.html">al_draw_rounded_rectangle</a></li><li><a href="al_draw_filled_rounded_rectangle.html">al_draw_filled_rounded_rectangle</a></li><li><a href="al_calculate_arc.html">al_calculate_arc</a></li><li><a href="al_draw_ellipse.html">al_draw_ellipse</a></li><li><a href="al_draw_filled_ellipse.html">al_draw_filled_ellipse</a></li><li><a href="al_draw_circle.html">al_draw_circle</a></li><li><a href="al_draw_filled_circle.html">al_draw_filled_circle</a></li><li><a href="al_draw_arc.html">al_draw_arc</a></li><li><a href="al_calculate_spline.html">al_calculate_spline</a></li><li><a href="al_draw_spline.html">al_draw_spline</a></li><li><a href="al_calculate_ribbon.html">al_calculate_ribbon</a></li><li><a href="al_draw_ribbon.html">al_draw_ribbon</a></li></ul></div><div id="low-level-drawing-routines"><h1><span>Low level drawing routines</span></h1><p>Low level drawing routines allow for more advanced usage of the addon, allowing you to pass arbitrary sequences of vertices to draw to the screen. These routines also support using textures on the primitives with some restrictions. For maximum portability, you should only use textures that have dimensions that are a power of two, as not every videocard supports them completely. This warning is relaxed, however, if the texture coordinates never exit the boundaries of a single bitmap (i.e. you are not having the texture repeat/tile). As long as that is the case, any texture can be used safely. Sub-bitmaps work as textures, but cannot be tiled.</p><p>A note about pixel coordinates. In OpenGL the texture coordinate (0, 0) refers to the top left corner of the pixel. This confuses some drivers, because due to rounding errors the actual pixel sampled might be the pixel to the top and/or left of the (0, 0) pixel. To make this error less likely it is advisable to offset the texture coordinates you pass to the al_draw_prim by (0.5, 0.5) if you need precise pixel control. E.g. to refer to pixel (5, 10) you'd set the u and v to 5.5 and 10.5 respectively.</p><ul><li><a href="al_draw_prim.html">al_draw_prim</a></li><li><a href="al_draw_indexed_prim.html">al_draw_indexed_prim</a></li><li><a href="al_create_vertex_decl.html">al_create_vertex_decl</a></li><li><a href="al_destroy_vertex_decl.html">al_destroy_vertex_decl</a></li><li><a href="al_draw_soft_triangle.html">al_draw_soft_triangle</a></li><li><a href="al_draw_soft_line.html">al_draw_soft_line</a></li></ul></div><div id="structures-and-types"><h1><span>Structures and types</span></h1><ul><li><a href="ALLEGRO_VERTEX.html">ALLEGRO_VERTEX</a></li><li><a href="ALLEGRO_VERTEX_DECL.html">ALLEGRO_VERTEX_DECL</a></li><li><a href="ALLEGRO_VERTEX_ELEMENT.html">ALLEGRO_VERTEX_ELEMENT</a></li><li><a href="ALLEGRO_PRIM_TYPE.html">ALLEGRO_PRIM_TYPE</a></li><li><a href="ALLEGRO_PRIM_ATTR.html">ALLEGRO_PRIM_ATTR</a></li><li><a href="ALLEGRO_PRIM_STORAGE.html">ALLEGRO_PRIM_STORAGE</a></li><li><a href="ALLEGRO_VERTEX_CACHE_SIZE.html">ALLEGRO_VERTEX_CACHE_SIZE</a></li><li><a href="ALLEGRO_PRIM_QUALITY.html">ALLEGRO_PRIM_QUALITY</a></li></ul></div></div>
</body>
<!-- Mirrored from www.allegro.cc/manual/5/primitives.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 26 Jun 2022 21:28:01 GMT -->
</html>